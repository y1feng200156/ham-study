<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>天线极化全家桶：9种经典天线演示</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #050505;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        background: rgba(0, 0, 0, 0.75);
        padding: 15px;
        border-radius: 8px;
        pointer-events: none;
        max-width: 360px;
        user-select: none;
        backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
      }
      h1 {
        margin: 0 0 8px 0;
        font-size: 1.3em;
        color: #4db8ff;
        text-shadow: 0 0 10px rgba(77, 184, 255, 0.5);
      }
      p {
        margin: 6px 0;
        font-size: 0.95em;
        line-height: 1.5;
      }
      .highlight {
        color: #ffcc00;
        font-weight: bold;
        font-size: 1.1em;
      }
      .legend {
        display: flex;
        align-items: center;
        margin-top: 8px;
        font-size: 0.85em;
      }
      .box {
        width: 12px;
        height: 12px;
        margin-right: 8px;
        display: inline-block;
        border-radius: 2px;
      }
      .red {
        background-color: #ff3333;
      }
      .grey {
        background-color: #aaaaaa;
      }
      .green {
        border: 2px solid #00ff00;
        box-sizing: border-box;
      }
      .blue {
        background-color: #00ffff;
        box-shadow: 0 0 5px #00ffff;
      }

      #controls {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(20, 20, 20, 0.9);
        padding: 12px 25px;
        border-radius: 40px;
        display: flex;
        gap: 15px;
        pointer-events: auto;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.1);
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
      }

      button {
        background: #333;
        color: white;
        border: 1px solid #555;
        padding: 10px 20px;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.2s ease-out;
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 6px;
        white-space: nowrap;
      }
      button:hover {
        background: #444;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }
      button:active {
        transform: translateY(0);
      }
      button.active {
        background: #4db8ff;
        color: #000;
        border-color: #4db8ff;
        box-shadow: 0 0 15px rgba(77, 184, 255, 0.4);
      }

      select {
        appearance: none;
        -webkit-appearance: none;
        background-color: #333;
        color: white;
        border: 1px solid #ffaa00;
        padding: 10px 35px 10px 20px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        outline: none;
        min-width: 200px;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23ffaa00%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
        background-repeat: no-repeat;
        background-position: right 15px top 50%;
        background-size: 10px auto;
        transition: all 0.2s;
      }
      select:hover {
        background-color: #444;
        box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
      }
      select option {
        background-color: #222;
        color: white;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <h1>无线电天线全家桶</h1>
      <p id="statusText">
        当前模式：<span class="highlight">垂直偶极子 (Vertical)</span>
      </p>
      <p
        style="
          font-size: 0.9em;
          color: #ccc;
          border-top: 1px solid rgba(255, 255, 255, 0.2);
          padding-top: 8px;
          margin-top: 8px;
          min-height: 40px;
        "
      >
        <span id="descText">基础垂直偶极子。全向辐射，电场垂直振动。</span>
      </p>
      <div class="legend"><span class="box red"></span>振子 (有源)</div>
      <div class="legend"><span class="box grey"></span>无源元件/地网</div>
      <div class="legend"><span class="box green"></span>辐射方向图</div>
      <div class="legend"><span class="box blue"></span>电磁波 (脉冲波)</div>
    </div>

    <div id="controls">
      <select id="modeSelect" title="选择天线类型"></select>
      <button id="togglePattern" class="active">显示方向图</button>
      <button id="toggleWaves" class="active">显示电波</button>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // 场景 setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050505);
      scene.fog = new THREE.Fog(0x050505, 30, 100);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(25, 20, 25);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // 辅助元素
      const axesHelper = new THREE.AxesHelper(3);
      axesHelper.position.y = 0.1;
      scene.add(axesHelper);

      const gridHelper = new THREE.GridHelper(60, 60, 0x333333, 0x111111);
      gridHelper.position.y = -5;
      scene.add(gridHelper);

      // 材质
      const matRed = new THREE.MeshPhongMaterial({
        color: 0xff3333,
        shininess: 80,
      });
      const matGrey = new THREE.MeshStandardMaterial({
        color: 0xaaaaaa,
        roughness: 0.4,
        metalness: 0.6,
      });
      const matDarkGrey = new THREE.MeshStandardMaterial({
        color: 0x444444,
        roughness: 0.8,
      });

      // --- 天线组 ---
      const antennaGroup = new THREE.Group();
      scene.add(antennaGroup);

      // 1. 垂直偶极子
      const antVertical = new THREE.Group();
      antVertical.add(
        new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 6, 16), matRed)
      );
      antVertical.add(
        new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), matDarkGrey)
      );
      antennaGroup.add(antVertical);

      // 2. 水平偶极子
      const antHorizontal = new THREE.Group();
      const hPole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2, 0.2, 6, 16),
        matRed
      );
      hPole.rotation.z = Math.PI / 2;
      antHorizontal.add(hPole);
      antHorizontal.add(
        new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), matDarkGrey)
      );
      antennaGroup.add(antHorizontal);

      // 3. 圆极化
      const antCircular = new THREE.Group();
      antCircular.add(antVertical.clone());
      const hPoleClone = hPole.clone();
      hPoleClone.rotation.x = Math.PI / 2;
      hPoleClone.rotation.z = Math.PI / 2;
      antCircular.add(hPoleClone);
      antennaGroup.add(antCircular);

      // 4. 八木天线
      const antYagi = new THREE.Group();
      const boom = new THREE.Mesh(new THREE.BoxGeometry(12, 0.3, 0.3), matGrey);
      boom.position.x = 2;
      antYagi.add(boom);
      antYagi.add(
        new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 7, 16), matGrey)
          .translateY(-3)
          .rotateX(Math.PI / 2)
          .rotateZ(Math.PI / 2)
      ); // ref fix position
      function createYagiElement(len, x, mat) {
        const el = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, len, 16),
          mat
        );
        el.rotation.x = Math.PI / 2;
        el.position.x = x;
        return el;
      }
      antYagi.clear();
      antYagi.add(boom);
      antYagi.add(createYagiElement(7.0, -3, matGrey)); // Reflector
      antYagi.add(createYagiElement(6.0, -1, matRed)); // Driven
      antYagi.add(createYagiElement(5.5, 1.5, matGrey)); // D1
      antYagi.add(createYagiElement(5.0, 4.0, matGrey)); // D2
      antennaGroup.add(antYagi);

      // 5. 倒V天线
      const antInvV = new THREE.Group();
      antInvV.add(
        new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 8, 8),
          matDarkGrey
        ).translateY(-4)
      );
      const leg1 = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 4, 16),
        matRed
      );
      leg1.geometry.translate(0, 2, 0);
      leg1.rotation.z = Math.PI / 4;
      antInvV.add(leg1);
      const leg2 = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 4, 16),
        matRed
      );
      leg2.geometry.translate(0, 2, 0);
      leg2.rotation.z = -Math.PI / 4;
      antInvV.add(leg2);
      antInvV.add(
        new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), matDarkGrey)
      );
      antennaGroup.add(antInvV);

      // 6. GP天线
      const antGP = new THREE.Group();
      antGP.add(
        new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.15, 4, 16),
          matRed
        ).translateY(2)
      );
      for (let i = 0; i < 4; i++) {
        const rad = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 4, 8),
          matGrey
        );
        rad.geometry.translate(0, 2, 0);
        rad.rotation.y = (Math.PI / 2) * i;
        rad.rotation.z = Math.PI / 2 + Math.PI / 6;
        antGP.add(rad);
      }
      antGP.add(
        new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), matDarkGrey)
      );
      antennaGroup.add(antGP);

      // 7. 正V天线
      const antPosV = new THREE.Group();
      const vLeg1 = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 4, 16),
        matRed
      );
      vLeg1.geometry.translate(0, 2, 0);
      vLeg1.rotation.z = -Math.PI / 6;
      antPosV.add(vLeg1);
      const vLeg2 = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 4, 16),
        matRed
      );
      vLeg2.geometry.translate(0, 2, 0);
      vLeg2.rotation.z = Math.PI / 6;
      antPosV.add(vLeg2);
      antPosV.add(
        new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), matDarkGrey)
      );
      antennaGroup.add(antPosV);

      // 8. 方框天线
      const antLoop = new THREE.Group();
      function createStick(p1, p2, mat) {
        const v1 = new THREE.Vector3(...p1);
        const v2 = new THREE.Vector3(...p2);
        const height = v1.distanceTo(v2);
        const mesh = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, height, 8),
          mat
        );
        const mid = v1.clone().add(v2).multiplyScalar(0.5);
        mesh.position.copy(mid);
        mesh.lookAt(v2);
        mesh.rotateX(Math.PI / 2);
        return mesh;
      }
      antLoop.add(createStick([-2, -2, 0], [2, -2, 0], matRed));
      antLoop.add(createStick([2, -2, 0], [2, 2, 0], matRed));
      antLoop.add(createStick([2, 2, 0], [-2, 2, 0], matRed));
      antLoop.add(createStick([-2, 2, 0], [-2, -2, 0], matRed));
      const loopFeed = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, 0.5, 0.5),
        matDarkGrey
      );
      loopFeed.position.set(0, -2, 0);
      antLoop.add(loopFeed);
      antennaGroup.add(antLoop);

      // 9. 莫克森天线
      const antMoxon = new THREE.Group();
      const moxonMat = matRed;
      const moxonRefMat = matGrey;
      antMoxon.add(createStick([-1, -1.5, 0], [-1, 1.5, 0], moxonMat));
      antMoxon.add(createStick([-1, -1.5, 0], [0.5, -1.5, 0], moxonMat));
      antMoxon.add(createStick([-1, 1.5, 0], [0.5, 1.5, 0], moxonMat));
      antMoxon.add(createStick([1.5, -1.5, 0], [1.5, 1.5, 0], moxonRefMat));
      antMoxon.add(createStick([1.5, -1.5, 0], [0.8, -1.5, 0], moxonRefMat));
      antMoxon.add(createStick([1.5, 1.5, 0], [0.8, 1.5, 0], moxonRefMat));
      const moxonFeed = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.4, 0.4),
        matDarkGrey
      );
      moxonFeed.position.set(-1, 0, 0);
      antMoxon.add(moxonFeed);
      antMoxon.rotation.y = Math.PI;
      antennaGroup.add(antMoxon);

      // --- 辐射方向图 ---
      const patternGeo = new THREE.SphereGeometry(1, 90, 60);
      const posAttribute = patternGeo.attributes.position;
      const originalPositions = [];
      for (let i = 0; i < posAttribute.count; i++) {
        originalPositions.push(
          new THREE.Vector3().fromBufferAttribute(posAttribute, i)
        );
      }
      const patternMesh = new THREE.Mesh(
        patternGeo,
        new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          wireframe: true,
          transparent: true,
          opacity: 0.15,
          side: THREE.DoubleSide,
        })
      );
      scene.add(patternMesh);

      // --- 波浪线系统 (使用VertexColors实现脉冲效果) ---
      const waveLinesGroup = new THREE.Group();
      scene.add(waveLinesGroup);
      const lineCount = 20;
      const segments = 250;
      const maxDist = 30;
      const minStart = 0.6; // 从天线表面开始，而不是中心
      const waveLines = [];

      for (let i = 0; i < lineCount; i++) {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(segments * 3);
        const colors = new Float32Array(segments * 3); // 颜色通道

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        // 使用顶点颜色材质，AdditiveBlending实现高亮叠加
        const material = new THREE.LineBasicMaterial({
          vertexColors: true,
          blending: THREE.AdditiveBlending,
          transparent: true,
          linewidth: 2,
        });

        const line = new THREE.Line(geometry, material);
        line.userData = { theta: (i / lineCount) * Math.PI * 2 };
        waveLines.push(line);
        waveLinesGroup.add(line);
      }

      // 灯光
      scene.add(new THREE.AmbientLight(0x333333));
      const dl = new THREE.DirectionalLight(0xffffff, 1.2);
      dl.position.set(10, 20, 10);
      scene.add(dl);

      // --- 状态机 ---
      const modes = [
        {
          id: 0,
          name: "垂直偶极子 (Vertical)",
          obj: antVertical,
          desc: "全向辐射。请注意：波形是向外飞出的脉冲。",
        },
        {
          id: 1,
          name: "水平偶极子 (Horizontal)",
          obj: antHorizontal,
          desc: "全向(垂直面)，8字形(水平面)。",
        },
        {
          id: 2,
          name: "圆极化 (Circular)",
          obj: antCircular,
          desc: "螺旋前进。波形像开瓶器一样旋转飞出。",
        },
        {
          id: 3,
          name: "八木天线 (Yagi)",
          obj: antYagi,
          desc: "强定向(+X)。能量主要向前喷射。",
        },
        {
          id: 4,
          name: "倒V天线 (Inverted V)",
          obj: antInvV,
          desc: "水平偶极子的变形。",
        },
        {
          id: 5,
          name: "GP天线 (Ground Plane)",
          obj: antGP,
          desc: "垂直单极天线。垂直极化波。",
        },
        {
          id: 6,
          name: "正V天线 (Positive V)",
          obj: antPosV,
          desc: "具有一定的定向性。",
        },
        {
          id: 7,
          name: "方框天线 (Loop/Quad)",
          obj: antLoop,
          desc: "前后双向辐射。",
        },
        {
          id: 8,
          name: "莫克森 (Moxon)",
          obj: antMoxon,
          desc: "高前后比，后方非常干净。",
        },
      ];
      let currentMode = 0;

      const modeSelect = document.getElementById("modeSelect");
      modes.forEach((m, index) => {
        const option = document.createElement("option");
        option.value = index;
        option.text = m.name;
        modeSelect.appendChild(option);
      });

      function updateState() {
        modes.forEach((m) => (m.obj.visible = false));
        modes[currentMode].obj.visible = true;
        document.getElementById("statusText").innerHTML =
          `当前模式：<span class="highlight" style="color:${getColor(currentMode)}">${modes[currentMode].name}</span>`;
        document.getElementById("descText").innerText = modes[currentMode].desc;
        modeSelect.value = currentMode;

        // Adjust wave origin
        if (currentMode === 3) waveLinesGroup.position.set(-1, 0, 0);
        else if (currentMode === 8) waveLinesGroup.position.set(1, 0, 0);
        else waveLinesGroup.position.set(0, 0, 0);

        patternMesh.rotation.set(0, 0, 0);
      }

      function getColor(mode) {
        if (mode === 3 || mode === 8) return "#55ff55";
        if (mode === 2) return "#ff55ff";
        return "#ffcc00";
      }

      modeSelect.addEventListener("change", (e) => {
        currentMode = parseInt(e.target.value);
        updateState();
      });
      updateState();

      const btnPat = document.getElementById("togglePattern");
      btnPat.addEventListener("click", () => {
        patternMesh.visible = !patternMesh.visible;
        btnPat.classList.toggle("active");
      });
      const btnWav = document.getElementById("toggleWaves");
      btnWav.addEventListener("click", () => {
        waveLinesGroup.visible = !waveLinesGroup.visible;
        btnWav.classList.toggle("active");
      });

      // --- 核心动画循环 ---
      let time = 0;
      function animate() {
        requestAnimationFrame(animate);
        time += 0.02; // 适中的速度
        controls.update();

        // 1. Update Pattern
        if (patternMesh.visible) {
          const pos = patternMesh.geometry.attributes.position;
          const scale = 10;
          for (let i = 0; i < pos.count; i++) {
            const orig = originalPositions[i];
            let gain = 0;
            const x = orig.x;
            const y = orig.y;
            const z = orig.z;
            switch (currentMode) {
              case 0:
                gain = Math.sqrt(x * x + z * z);
                break;
              case 1:
              case 4:
              case 6:
                gain = Math.sqrt(y * y + z * z);
                break;
              case 2:
                gain = 0.8 + 0.2 * Math.sqrt(x * x + z * z);
                break;
              case 3:
                gain =
                  x > 0
                    ? Math.pow(x, 3) * 1.5
                    : 0.2 * Math.abs(Math.cos(x * 5));
                break;
              case 5:
                gain = Math.sqrt(x * x + z * z);
                break;
              case 7:
                gain = Math.pow(Math.abs(z), 0.7);
                break;
              case 8:
                gain = (1 + x) * 0.6;
                if (gain < 0.2) gain = 0.05;
                break;
            }
            const v = orig.clone().multiplyScalar(gain * scale);
            pos.setXYZ(i, v.x, v.y, v.z);
          }
          pos.needsUpdate = true;
        }

        // 2. Update Wave Lines (Pulse Mode)
        if (waveLinesGroup.visible) {
          waveLines.forEach((line) => {
            const positions = line.geometry.attributes.position.array;
            const colors = line.geometry.attributes.color.array;
            const theta = line.userData.theta;
            const dirX = Math.cos(theta);
            const dirZ = Math.sin(theta);
            const dirVec = new THREE.Vector3(dirX, 0, dirZ).normalize();
            let gain = 1.0;

            if (currentMode === 0 || currentMode === 5) gain = 1.0;
            else if (
              currentMode === 1 ||
              currentMode === 4 ||
              currentMode === 6
            )
              gain = Math.abs(dirVec.z);
            else if (currentMode === 3)
              gain = dirVec.x > 0 ? Math.pow(dirVec.x, 2) : 0.1;
            else if (currentMode === 7) gain = Math.abs(dirVec.z);
            else if (currentMode === 8) {
              gain = (1 + dirVec.x) * 0.5;
              if (gain < 0.2) gain = 0;
            }

            for (let j = 0; j < segments; j++) {
              // 距离从天线表面开始 (minStart)
              const r = minStart + (j / segments) * (maxDist - minStart);
              const baseX = dirX * r;
              const baseZ = dirZ * r;

              // 波动参数
              const k = 2.0;
              const w = 6.0;
              const phase = k * r - time * w;

              // 移除起步缓动 (Start Envelope)，让波直接存在
              // 仅保留末端自然消散
              const endEnvelope = Math.max(
                0,
                1.0 - Math.pow(r / (maxDist * 0.95), 3)
              );
              const decay = 4.0 / (r + 1.0);

              // 基础振幅
              const amp = decay * gain * endEnvelope;
              const waveVal = Math.sin(phase);

              let x = baseX;
              let y = 0;
              let z = baseZ;

              if (currentMode === 0 || currentMode === 5) {
                y = amp * waveVal;
              } else if (
                currentMode === 1 ||
                currentMode === 3 ||
                currentMode === 4 ||
                currentMode === 6 ||
                currentMode === 8 ||
                currentMode === 7
              ) {
                const tanX = -Math.sin(theta);
                const tanZ = Math.cos(theta);
                x += tanX * amp * waveVal;
                z += tanZ * amp * waveVal;
              } else if (currentMode === 2) {
                const vComp = Math.sin(phase);
                const hComp = Math.cos(phase);
                const tanX = -Math.sin(theta);
                const tanZ = Math.cos(theta);
                y = amp * vComp;
                x += tanX * amp * hComp;
                z += tanZ * amp * hComp;
              }

              positions[j * 3] = x;
              positions[j * 3 + 1] = y;
              positions[j * 3 + 2] = z;

              // --- 颜色处理 (关键) ---
              // 根据波峰波谷计算透明度。
              // Math.abs(waveVal) 接近1时最亮，接近0时全透明。
              // pow(..., 3) 是为了让亮的部分更窄，看起来更像独立的脉冲。
              let intensity = Math.pow(Math.abs(waveVal), 3.0);
              intensity *= Math.min(1.0, r * 0.5); // 防止在极近处太亮刺眼
              intensity *= endEnvelope; // 末端淡出

              // 基础青色 (0, 1, 1)
              colors[j * 3] = 0.0 * intensity; // R
              colors[j * 3 + 1] = 1.0 * intensity; // G
              colors[j * 3 + 2] = 1.0 * intensity; // B
            }
            line.geometry.attributes.position.needsUpdate = true;
            line.geometry.attributes.color.needsUpdate = true;
          });
        }

        if (currentMode === 2 && patternMesh.visible)
          patternMesh.rotation.y += 0.002;
        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
